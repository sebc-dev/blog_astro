---
description: ""
globs: ["*.test.ts", "*.test.js", "*.spec.ts", "*.spec.js", "vitest.config.*", "**/test/**/*", "**/tests/**/*", "**/__tests__/**/*"]
alwaysApply: false
---

# Guide complet : Vitest pour applications Astro avec TypeScript

## Configuration optimale et structure projet

**Configuration Vitest moderne pour Astro 5+** utilise la fonction `getViteConfig` d'Astro pour une int√©gration transparente. Le fichier `vitest.config.ts` optimal combine les avantages de Vite avec les sp√©cificit√©s d'Astro :

```typescript
/// <reference types="vitest" />
import { getViteConfig } from 'astro/config';

export default getViteConfig({
  test: {
    environment: 'happy-dom', // Plus rapide que jsdom
    setupFiles: ['./src/test/setup.ts'],
    globals: true,
    include: ['src/**/*.{test,spec}.{js,ts,jsx,tsx}'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'html', 'json'],
      exclude: ['coverage/**', 'dist/**', '.astro/**']
    }
  }
});
```

La **configuration TypeScript** pour les tests n√©cessite des types sp√©cifiques et une r√©solution de modules adapt√©e. Le `tsconfig.json` doit inclure les r√©f√©rences Vitest et supporter l'√©cosyst√®me Astro :

```json
{
  "extends": "astro/tsconfigs/strict",
  "compilerOptions": {
    "target": "ES2022",
    "moduleResolution": "bundler",
    "types": ["vitest/globals", "@astrojs/check", "node"],
    "paths": {
      "@/*": ["src/*"],
      "@/components/*": ["src/components/*"]
    }
  }
}
```

**Structure de projet recommand√©e** suit trois approches principales. La plus populaire utilise des dossiers `__tests__` adjacents aux composants, permettant une organisation claire et une maintenance facilit√©e.

## Patterns de test sp√©cifiques √† Astro

**Tests de composants avec Container API** constituent le c≈ìur du testing Astro moderne. Cette API exp√©rimentale mais officielle permet de rendre les composants Astro en isolation compl√®te :

```typescript
import { experimental_AstroContainer as AstroContainer } from 'astro/container';
import { expect, test } from 'vitest';
import Card from './Card.astro';

test('Card renders with props and slots', async () => {
  const container = await AstroContainer.create();
  const result = await container.renderToString(Card, {
    props: { title: 'Test Card', date: '2024-01-01' },
    slots: { default: 'Card content', header: '<span>Custom header</span>' }
  });
  
  expect(result).toContain('Test Card');
  expect(result).toContain('Card content');
});
```

**Tests d'API routes** n√©cessitent une approche diff√©rente utilisant la m√©thode `renderToResponse` pour simuler des requ√™tes HTTP compl√®tes :

```typescript
test('API endpoint returns JSON', async () => {
  const container = await AstroContainer.create();
  const response = await container.renderToResponse(
    import('./api/posts.ts'),
    { request: new Request('http://localhost:4321/api/posts') }
  );
  
  expect(response.status).toBe(200);
  const data = await response.json();
  expect(Array.isArray(data)).toBe(true);
});
```

**Tests de pages et layouts** combinent rendu de composants et v√©rification de structure HTML. Ces tests v√©rifient l'int√©gration correcte des m√©tadonn√©es, de la navigation et du contenu.

## Mocking et gestion des modules Astro

**Strat√©gies de mocking** pour l'√©cosyst√®me Astro n√©cessitent une attention particuli√®re aux modules virtuels et aux imports dynamiques. Vitest offre des capacit√©s de mocking puissantes adapt√©es √† Astro :

```typescript
import { vi } from 'vitest';

// Mock des collections de contenu
vi.mock('astro:content', () => ({
  getCollection: vi.fn().mockResolvedValue([
    { slug: 'post-1', data: { title: 'Mock Post' } }
  ])
}));

// Mock des assets Astro
vi.mock('astro:assets', () => ({
  Image: ({ src, alt }) => `<img src="${src}" alt="${alt}" />`
}));
```

**Gestion des d√©pendances externes** implique souvent de mocker des APIs, des services tiers, ou des modules Node.js. La strat√©gie consiste √† isoler les tests de toute d√©pendance externe non contr√¥l√©e.

## Pi√®ges de mocking et solutions Vitest

### ‚ö†Ô∏è Probl√®me : Hoisting des mocks et variables non initialis√©es

**Probl√®me fr√©quent** : Vitest hisse les appels `vi.mock()` en haut du fichier, causant des erreurs "Cannot access before initialization" :

```typescript
// ‚ùå ERREUR : ReferenceError
const mockDomUtils = {
  getElementById: vi.fn(),
  addClass: vi.fn()
};

vi.mock("../utils/dom", () => mockDomUtils); // Hiss√© avant la d√©claration
```

**Solution recommand√©e** : Utiliser la factory function inline et importer le module r√©el pour le typage :

```typescript
// ‚úÖ CORRECT : Mock inline avec factory function
import * as domUtils from "../utils/dom";

vi.mock("../utils/dom", () => ({
  getElementById: vi.fn(),
  addClass: vi.fn(),
  removeClass: vi.fn(),
  setBodyOverflow: vi.fn(),
  querySelectorAll: vi.fn(),
}));

// Typage des mocks apr√®s l'import
const mockGetElementById = vi.mocked(domUtils.getElementById);
const mockAddClass = vi.mocked(domUtils.addClass);
```

### üîß Pattern optimal pour mocking de modules utilitaires

**Structure recommand√©e** pour mocker des modules avec de nombreuses fonctions :

```typescript
import { describe, it, expect, beforeEach, vi } from "vitest";
import { MyComponent } from "../components/MyComponent";
import * as utilsModule from "../utils/myUtils";

// Mock complet du module
vi.mock("../utils/myUtils", () => ({
  helperFunction: vi.fn(),
  calculateValue: vi.fn(),
  formatData: vi.fn(),
  validateInput: vi.fn(),
}));

describe("MyComponent", () => {
  // R√©cup√©ration typ√©e des mocks
  const mockHelperFunction = vi.mocked(utilsModule.helperFunction);
  const mockCalculateValue = vi.mocked(utilsModule.calculateValue);
  
  beforeEach(() => {
    vi.clearAllMocks();
    
    // Configuration des valeurs de retour par d√©faut
    mockHelperFunction.mockReturnValue("default");
    mockCalculateValue.mockReturnValue(42);
  });
});
```

### üéØ Gestion des NodeListOf et types DOM complexes

**Probl√®me sp√©cifique** : Simuler des types DOM complexes comme `NodeListOf<HTMLElement>` :

```typescript
// ‚úÖ Simulation correcte de NodeListOf
const mockNavLinks = {
  length: 2,
  item: vi.fn(),
  forEach: vi.fn((callback) => {
    callback(navLink1, 0, mockNavLinks);
    callback(navLink2, 1, mockNavLinks);
  }),
  [0]: navLink1,
  [1]: navLink2,
} as unknown as NodeListOf<HTMLElement>;

// Mock avec gestion des cas vides
const emptyNodeList = {
  length: 0,
  item: vi.fn().mockReturnValue(null),
  forEach: vi.fn(),
} as unknown as NodeListOf<HTMLElement>;
```

### üîÑ Reset et isolation des mocks

**Bonnes pratiques** pour √©viter la pollution entre tests :

```typescript
describe("Component Tests", () => {
  beforeEach(() => {
    // Nettoyage complet des mocks
    vi.clearAllMocks();
    
    // R√©initialisation des impl√©mentations si n√©cessaire
    mockFunction.mockImplementation(() => defaultBehavior);
  });

  afterEach(() => {
    // Nettoyage des timers et autres ressources
    vi.clearAllTimers();
    vi.unstubAllGlobals();
  });
});
```

### üö® √âviter les anti-patterns courants

**Anti-patterns √† √©viter** :

```typescript
// ‚ùå Variables globales dans les mocks
let globalMockState = {};
vi.mock("module", () => ({ getValue: () => globalMockState }));

// ‚ùå Mocks trop complexes
vi.mock("complex-module", () => {
  // 50+ lignes de logique complexe...
});

// ‚ùå R√©utilisation de mocks entre fichiers sans isolation
```

**Alternatives recommand√©es** :

```typescript
// ‚úÖ State local dans les tests
describe("Tests", () => {
  let localState: any;
  
  beforeEach(() => {
    localState = {};
    mockFunction.mockImplementation(() => localState);
  });
});

// ‚úÖ Factories pour mocks complexes
function createMockComplexModule(overrides = {}) {
  return {
    defaultMethod: vi.fn(),
    complexMethod: vi.fn(),
    ...overrides
  };
}
```

## Optimisation des performances et configuration avanc√©e

**Optimisations critiques** pour les performances incluent l'utilisation de `pool: 'threads'` avec `isolate: false` pour les projets o√π l'isolation stricte n'est pas n√©cessaire. Cette configuration peut r√©duire les temps d'ex√©cution de **60-75%** :

```typescript
export default getViteConfig({
  test: {
    pool: 'threads',
    isolate: false, // Attention : risque de pollution entre tests
    maxConcurrency: 20,
    environment: 'happy-dom', // 2x plus rapide que jsdom
    css: false // Skip CSS processing pour les tests unitaires
  }
});
```

**Sharding des tests** devient essentiel pour les grandes suites de tests. Cette technique divise l'ex√©cution sur plusieurs processus :

```yaml
# GitHub Actions avec sharding
strategy:
  matrix:
    shardIndex: [1, 2, 3, 4]
    shardTotal: [4]
steps:
  - run: npm test -- --shard=${{ matrix.shardIndex }}/${{ matrix.shardTotal }}
```

## Outils compl√©mentaires et int√©gration CI/CD

**Stack d'outils recommand√©e** combine Vitest avec des solutions compl√©mentaires pour une couverture compl√®te :

- **Playwright** pour les tests end-to-end avec une int√©gration native Vitest
- **MSW (Mock Service Worker)** pour mocker les APIs de mani√®re r√©aliste  
- **Testing Library** pour les queries DOM avanc√©es
- **Storybook** avec test-runner pour les tests de composants isol√©s

**Configuration CI/CD optimis√©e** utilise la mise en cache NPM, l'ex√©cution parall√®le et la g√©n√©ration de rapports de couverture :

```yaml
- name: Run tests
  run: npm run test:ci
  env:
    CI: true
- name: Upload coverage
  uses: codecov/codecov-action@v3
  with:
    file: ./coverage/lcov.info
```

## Gestion des assets et debugging avanc√©

**Tests d'assets et styles** n√©cessitent des approches sp√©cifiques pour valider l'optimisation d'images, les CSS modules et les ressources statiques :

```typescript
test('Image optimization works', async () => {
  const optimizedImage = await getImage({
    src: heroImage,
    width: 800,
    format: 'webp'
  });
  
  expect(optimizedImage.src).toContain('.webp');
  expect(optimizedImage.attributes.width).toBe(800);
});
```

**Debugging avec VS Code** s'appuie sur des configurations de launch sp√©cifiques permettant le debugging interactif avec breakpoints :

```json
{
  "type": "node",
  "request": "launch",
  "name": "Debug Current Test File",
  "program": "${workspaceRoot}/node_modules/vitest/vitest.mjs",
  "args": ["run", "${relativeFile}"],
  "console": "integratedTerminal"
}
```

## Migration Jest vers Vitest et cas d'usage avanc√©s

**Migration Jest vers Vitest** se fait en trois √©tapes principales : changement des d√©pendances, adaptation de la configuration, et mise √† jour de l'API de mocking. La compatibilit√© √©tant √©lev√©e, la plupart des tests existants fonctionnent avec des modifications minimes.

**Tests SSR et middleware** exploitent les capacit√©s avanc√©es du Container API pour simuler des contextes de serveur complets :

```typescript
test('SSR page with context', async () => {
  const container = await AstroContainer.create({ streaming: true });
  const response = await container.renderToResponse(Page, {
    request: new Request('http://localhost:4321/ssr-page'),
    locals: { user: { id: 1 } }
  });
  
  expect(response.status).toBe(200);
});
```

## √âvolutions r√©centes et perspectives d'avenir

**D√©veloppements 2024-2025** incluent l'am√©lioration du mode navigateur Vitest, l'API Container stabilis√©e, et la compatibilit√© Vite 6. La **version Vitest 3** (janvier 2025) apportera une meilleure int√©gration avec Astro 5 et des performances encore am√©lior√©es.

**Matrice de compatibilit√©** actuelle recommande Vitest 2.x avec Astro 4.x-5.x, en utilisant des overrides pour g√©rer les conflits de versions Vite temporaires.

La combinaison Vitest + Astro + TypeScript repr√©sente l'√©tat de l'art du testing moderne pour les applications web statiques et hybrides, offrant une exp√©rience d√©veloppeur excellente avec des performances de test exceptionnelles.